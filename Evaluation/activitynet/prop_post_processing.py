# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
import json
import multiprocessing as mp
import os
import math
from joblib import Parallel, delayed


def iou_with_anchors(anchors_min, anchors_max, box_min, box_max):
    """Compute jaccard score between a box and the anchors.
    """
    len_anchors = anchors_max - anchors_min
    int_xmin = np.maximum(anchors_min, box_min)
    int_xmax = np.minimum(anchors_max, box_max)
    inter_len = np.maximum(int_xmax - int_xmin, 0.)
    union_len = len_anchors - inter_len + box_max - box_min
    # print inter_len,union_len
    jaccard = np.divide(inter_len, union_len)
    return jaccard

def load_json(file):
    with open(file) as json_file:
        data = json.load(json_file)
        return data


def getDatasetDict(opt):
    anno_df = pd.read_csv(opt["video_info"])
    anno_database = load_json(opt["video_anno"])

    video_dict = {}
    for i in range(len(anno_df)):
        video_name = anno_df.video.values[i]

        if video_name == 'v_Bg-0ibLZrgg' or video_name == 'v_0dkIbKXXFzI' or video_name == 'v_fmtW5lcdT_0' or video_name == 'v_x0PE_98UO3s':
            continue

        video_info = anno_database[video_name]
        video_new_info = {}
        video_new_info['duration_frame'] = video_info['duration_frame']
        video_new_info['duration_second'] = video_info['duration_second']
        video_new_info["feature_frame"] = video_info['feature_frame']
        video_subset = anno_df.subset.values[i]
        video_new_info['annotations'] = video_info['annotations']
        if video_subset == 'validation':
            video_dict[video_name] = video_new_info
    # for key, value in database.items():
    #     video_name = key
    #     video_info = value
    #     video_new_info = {}
    #     video_subset = video_info['subset']
    #     video_new_info['duration_frame'] = video_info['duration_frame']
    #     video_new_info['duration_second'] = video_info['duration_second']
    #     video_new_info["feature_frame"] = video_info['feature_frame']
    #     video_new_info['annotations'] = video_info['annotations']
    #     if video_subset == 'validation':
    #         video_dict[video_name] = video_new_info
    return video_dict


def soft_nms(df, alpha, t1, t2):
    '''
    df: proposals generated by network;
    alpha: alpha value of Gaussian decaying function;
    t1, t2: threshold for soft nms.
    '''
    df = df.sort_values(by="score", ascending=False)
    tstart = list(df.xmin.values[:])
    tend = list(df.xmax.values[:])
    tscore = list(df.score.values[:])

    rstart = []
    rend = []
    rscore = []

    while len(tscore) > 1 and len(rscore) < 101:
        max_index = tscore.index(max(tscore))
        tmp_iou_list = iou_with_anchors(
            np.array(tstart),
            np.array(tend), tstart[max_index], tend[max_index])
        for idx in range(0, len(tscore)):
            if idx != max_index:
                tmp_iou = tmp_iou_list[idx]
                tmp_width = tend[max_index] - tstart[max_index]
                if tmp_iou > t1 + (t2 - t1) * tmp_width:
                    tscore[idx] = tscore[idx] * np.exp(-np.square(tmp_iou) /
                                                       alpha)

        rstart.append(tstart[max_index])
        rend.append(tend[max_index])
        rscore.append(tscore[max_index])
        tstart.pop(max_index)
        tend.pop(max_index)
        tscore.pop(max_index)

    newDf = pd.DataFrame()
    newDf['score'] = rscore
    newDf['xmin'] = rstart
    newDf['xmax'] = rend
    return newDf


def post_process_video(opt, idx, video_name, video_info):

    df = pd.read_csv(os.path.join(opt["output_path"], opt["prop_path"]) + "/" + video_name + ".csv")

    if len(df) > 1:
        snms_alpha = opt["nms_alpha_prop"]
        snms_t1 = opt["nms_lthr_prop"]
        snms_t2 = opt["nms_hthr_prop"]
        df = soft_nms(df, snms_alpha, snms_t1, snms_t2)

    df = df.sort_values(by="score", ascending=False)
    video_duration = float(video_info["duration_frame"] // 16 * 16) / video_info["duration_frame"] * video_info[
        "duration_second"]
    proposal_list = []

    for j in range(min(100, len(df))):
        tmp_proposal = {}
        tmp_proposal["score"] = df.score.values[j]
        tmp_proposal["segment"] = [max(0, df.xmin.values[j]) * video_duration,
                                   min(1, df.xmax.values[j]) * video_duration]
        proposal_list.append(tmp_proposal)

    # print('The {}-th video {} is finished'.format(idx, video_name))
    return {video_name[2:]: proposal_list}


def post_processing_multiproc(opt):
    video_dict = getDatasetDict(opt)
    video_list = list(video_dict.keys())  # [:100]

    props = Parallel(n_jobs=opt["post_process_thread"])(
        delayed(post_process_video)(
            opt,
            idx,
            video_name,
            video_dict[video_name]
        ) for idx, video_name in enumerate(video_list))
    result_dict={}
    [result_dict.update(p) for p in props]

    output_dict = {"version": "VERSION 1.3", "results": result_dict, "external_data": {}}
    outfile = open(os.path.join(opt["output_path"],opt["prop_result_file"]), "w")
    json.dump(output_dict, outfile)
    outfile.close()

# =====================================================================================================
# ==================================Option 0 for multiproc=============================================
# =====================================================================================================

def post_processing_multiproc0(opt):
    video_dict = getDatasetDict(opt)
    video_list = list(video_dict.keys())  # [:100]
    global result_dict
    result_dict = mp.Manager().dict()

    num_videos = len(video_list)
    num_videos_per_thread = math.ceil( num_videos / opt["post_process_thread"])
    processes = []
    for tid in range(opt["post_process_thread"] - 1):
        tmp_video_list = video_list[tid * num_videos_per_thread:(tid + 1) * num_videos_per_thread]
        p = mp.Process(target=post_process, args=(opt, tmp_video_list, video_dict))
        p.start()
        processes.append(p)
    tmp_video_list = video_list[(opt["post_process_thread"] - 1) * num_videos_per_thread:]
    p = mp.Process(target=post_process, args=(opt, tmp_video_list, video_dict))
    p.start()
    processes.append(p)
    for p in processes:
        p.join()

    result_dict = dict(result_dict)
    output_dict = {"version": "VERSION 1.3", "results": result_dict, "external_data": {}}
    outfile = open(os.path.join(opt["output_path"],opt["prop_result_file"]), "w")
    json.dump(output_dict, outfile)
    outfile.close()


def post_process(opt, video_list, video_dict):
    for video_name in video_list:
        df = pd.read_csv(os.path.join(opt["output_path"], opt["prop_path"]) + "/" + video_name + ".csv")

        if len(df) > 1:
            snms_alpha = opt["nms_alpha_prop"]
            snms_t1 = opt["nms_lthr_prop"]
            snms_t2 = opt["nms_hthr_prop"]
            df = soft_nms(df, snms_alpha, snms_t1, snms_t2)

        df = df.sort_values(by="score", ascending=False)
        video_info = video_dict[video_name]
        video_duration = float(video_info["duration_frame"] // 16 * 16) / video_info["duration_frame"] * video_info[
            "duration_second"]
        proposal_list = []

        for j in range(min(100, len(df))):
            tmp_proposal = {}
            tmp_proposal["score"] = df.score.values[j]
            tmp_proposal["segment"] = [max(0, df.xmin.values[j]) * video_duration,
                                       min(1, df.xmax.values[j]) * video_duration]
            proposal_list.append(tmp_proposal)
        result_dict[video_name[2:]] = proposal_list